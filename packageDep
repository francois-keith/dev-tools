#! /usr/bin/perl  --                                                                                -*-perl-*-

##########
# README #
##########
#
# This scripts allows automatic extraction of package dependencies
# It is a perl script. To use it:
# $ chmod u+x packageDep
# $ cd /tmp && /path/to/packageDep -p foo
#
# It will create a text file in /tmp/foo.

use strict;
use warnings;
use Getopt::Long;

my ($pkg, $outputFile, $print_version, $print_help);
my $usage = "packageDep -p <packageName> -o <outputFile>";
my $version = "0.1";

my $number = '-?\d+\.?\d*[eE]?-?\d*';
my $versionNumber = '\d+\..*';
my $name = '[\w\d\.\/_-]+';

$pkg="";
$outputFile="";

usage() if !GetOptions("version|v"   => \$print_version,
                       "help|h"      => \$print_help,
                       "package|p=s" => \$pkg,
                       "output|o=s" => \$outputFile);

if ($pkg eq '') {
    usage ();
}

if ($print_version) {
    print "packageDep version $version\n";
    exit;
}

if ($print_help) {
    print "$usage\n
  Generate a text file describing the dependencies of a package

  --version|-v
     print version information.

  --help|-?
    print help.\n";
    exit;
}

sub usage {
    print "Unknown option: @_\n" if ( @_ );
    print "$usage\n";
    print "Use --help for additional information.\n";
    exit;
}


my $pkgConfigPath = $ENV{"PKG_CONFIG_PATH"};

my @path = split(/:/, $pkgConfigPath);
my $key;
my $value;

# Gather all packages in this array to avoid handling them several times.
my %allPkg;
$allPkg{"$pkg"} = $pkg;

# Gather all dependencies in this array to avoid hanlding them several times.
my %allDep;
my ($i, $j);

#
#  Loop over each path of PKG_CONFIG_PATH
#

sub extractDep {
  my $argument = $_[0];
  my $found=0;
  my @dep;
  my @dep2;

  print "Scanning $argument\n";

  for ($i=0; $i < scalar(@path); $i++) {
    my $filePc = "$path[$i]/$argument.pc";

    if (open(INPUT, $filePc)) {
      while (<INPUT>) {
	if ((/^(\s*Requires:\s+)(.+)/)) {
	  my $line = $2;
	  @dep = split(/,/, $line);
	  $found=1;
	  for ($j=0; $j < scalar(@dep); $j++) {
	    if (($dep[$j] =~ (/^\s*($name)\s+>=\s+($versionNumber)/)) ||
		($dep[$j] =~ (/^\s*($name)\s*/))) {
	      $dep2[$j] = $1;
	      print "  $dep2[$j]\n";
	      my $tmpDep = "$1 -> $argument";
	      $allPkg{$1} = $1;
	      $allDep{$tmpDep} = $tmpDep;
	    }
	    else {
	      $dep2[$j] = "";
	    }
	  }
	}
      }
      close(INPUT);
    }
    if ($found) {
      my $sizeDep2=scalar(@dep2);
      print "size of dep2 = $sizeDep2\n";
      for ($j=0; $j < $sizeDep2; $j++) {
	if ($dep2[$j] ne "") {
	    my @newDeps = extractDep($dep2[$j]);
	    push(@dep2, @newDeps);
	}
      }
    }
  }
  return @dep2;
}

#
# Recursively extract packages and dependencies
#
extractDep ($pkg);

#
# Parse array of packages and dependencies
#
open(OUTPUT, ">".$outputFile) or die ("cannot open $outputFile");

print OUTPUT "digraph CD  {\n";
print OUTPUT "\tsize = \"12,15\"\n";
print OUTPUT "\trankdir = BT\n";
print OUTPUT "\tcompound=true\n";
print OUTPUT "\n";

my @packages = keys(%allPkg);
my @dependencies = keys(%allDep);

for ($i=0; $i<scalar(@packages); $i++) {
  print OUTPUT "\t$packages[$i] [shape = box]\n";
}

for ($i=0; $i<scalar(@dependencies); $i++) {
  print OUTPUT "\t$dependencies[$i]\n";
}

print OUTPUT "}\n";
